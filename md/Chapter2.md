# 2장 - 코틀린 기초

**2장에서 다루는 내용** 

- 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기
  

<br/>

## 2.1 기본 요소: 함수와 변수
### 2.1.1 Hello, World
  ```kotlin
fun main(args: Array<String>) {
	println("Hello, World!")
}
  ```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다.
- 클래스 안에 함수를 넣어야 할 필요가 없고, 함수를 최상위 수준에 정의할 수 있다.
- 배열 처리를 위한 문법이 따로 존재하지 않는다.
- 자바의 System.out.println 대신 `println`을 사용한다.

### 2.1.2 함수
아무런 값도 반환하지 않는 함수는 방금 살펴봤지만 의미 있는 결과를 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까?

```kotlin
fun max(a: Int, b: Int): Int {
	return if (a > b) a else b
}

println(max(1, 2))
// 2
```

함수 선언은 fun 키워드로 시작하며, 그 다음에는 함수의 이름이 온다. 함수 이름 뒤에는 괄포 안에 파라미터 목록이 온다. 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론으로 구분한다.
<img width="801" alt="스크린샷 2021-09-12 23 25 07" src="https://user-images.githubusercontent.com/52916061/132991442-fddf16de-ce5b-4b17-9936-eaad93cc55b2.png">

🥀`문(statement)`과 `식(expression)`의 구분 <br/>
**식**은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
**문**은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.
자바에서는 모든 제어 구조가 문인 반면, 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.

### A. 식이 본문인 함수
앞에서 살펴본 함수를 더 간결하게 표현할 수도 있다. 앞의 함수 본문은 if 식 하나로만 이뤄져 있는데, 다음과 같이 중괄호를 없애고 return을 제거하면서 등호를 식 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a>b) a else b
```

본문이 중괄호로 둘러싸인 함수를 `블록이 본문인 함수`라 부르고, 등호와 식으로 이뤄진 함수를 `식이 본문인 함수`라고 한다.

코틀린에서는 식이 본문이 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다. 

반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a>b) a else b
```

코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 하는데, 여기서 반환 타입을 생략할 수 있는 이유는 무엇일까? 

실제로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해져야 한다. 하지만 **식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.**

이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 `타입 추론(type inference)`이라 부른다. 

식이 본문이 함수의 반환 타입만 생략 가능하다는 점에 유의해야 한다. 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.

<br/>

### 2.1.3 변수
코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

```kotlin
val question = "삶이란?"
val answer = 32
```

식이 본문인 함수에서와 마찬가지로 우리가 타입을 지정하지 않으면 컴파일러가 **초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정**한다.
초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 대문에 컴파일러가 타입을 추론할 수 없다.

### A. 변경 가능한 변수와 변경 불가능한 변수
  변수 선언 시 사용하는 키워드는 다음과 같이 2가지가 있다.

- **`val`** (값을 뜻하는 value에서 따옴)
    - 변경 불가능한(immutavle) 참조를 저장하는 변수다. val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. 
      (자바의 final 변수에 해당)
- **`var`** (변수를 뜻하는 variable에서 따옴)
    - 변경 가능한(mutable) 참조다. 이런 변수의 값은 바뀔 수 있다. (자바의 일반 변수에 해당)

기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하는 것을 추천한다고 한다.

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```kotlin
val message: String
if (canPerformOperation()) {
	message = "Success"
	// 연산 수행 ..
} else {
	message = "Failed"
}
```

val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하라.

```kotlin
val languages = arrayListOf("Java") //불변 참조 선언
languages.add("Kotlin")             //참조가 가리키는 객체 내부를 변경
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

```kotlin
var answer = 42
answer = "no answer"  //"Error: type mismatch" 컴파일 오류 발생
```

문자열 리터럴에서 컴파일 오류가 발생한다. 이유는 String 타입이 컴파일러가 기대하는 타입과 다르기 때문이다. **컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며, 변수 선언 이후 변수 제대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사**한다.

어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다.

<br/>

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿
다음은 Hello,World 예제의 다음 단계로, 사람 이름을 사용해 환영 인사를 출력하는 코틀린 프로그램이다.

```kotlin
fun main(args: Array<String>) {
	val name = if (args.size > 0) args[0] else "Kotlin"
	println("Hello, $name")
}
```

이 예제는 `문자열 템플릿` 이라는 기능을 보여준다. 이 코드는 name이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 그 변수를 사용했다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 `$`를 추가해야 한다. 
물론 컴파일러는 각 식을 정적(static)으로  검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.

<br/>

## 2.2 클래스와 프로퍼티
  이번에는 클래스를 선언하는 기본 문법을 소개한다. 자세한 내용은 뒷 부분에서 다룬다.

시작하기 위해 간단한 자바빈(JavaBean) 클래스인 Person을 정의한다. Person에는 name이라는 프로퍼티(property)만 들어있다.

```java
public class Person {
	private final String name;
	
	public Person(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}
}
```

필드가 둘 이상으로 늘어나면 생성자인 `Person(String name)`의 본문에서 파라미터를 이름이 같은 필드에 대입하는 대입문의 수도 늘어난다. 코틀린에서는 그런 필드 대입 로직을 훨씬 더 적은 코드로 작성할 수 있다.

자바-코틀린 변환기는 자바 코드를 같은 일을 하는 코틀린 코드로 자동으로 변환해준다. 변환기를 써서 방금 본 Person 클래스를 코틀린으로 변환해보자.

```kotlin
class Person(val name: String)
```

이런 유형의 클래스(코드가 없이 데이터만 저장하는 클래스)를 `값 객체(value object)`라 부르며, 다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.

코틀린으로 변환한 결과, public 가시성 변경자가 사라졌음을 확인할 수 있다. **코틀린의 기본 가시성은 public**이므로 생략할 수 있다.

<br/>

### 2.2.1 프로퍼티
`클래스`라는 개념의 목적은 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다. 자바에서는 데이터를 필드에 저장하며, 멤버 필드의 가시성은 보통 비공개이다. 클래스는 자신을 사용하는 클라이언트가 그 데이터에 접근하는 통로로 쓸 수 있는 접근자 메소드를 제공한다. 보통은 필드를 읽기를 위한 게터를 제공하고, 필드를 변경하게 허용해야 할 경우 세터를 추가 제공할 수 있다.

자바에서는 필드와 접근자를 묶어 `프로퍼티(property)`라고 부른다. 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, **코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신**한다. 

클래스에서 프로퍼티를 선언할 때는 앞에서 살펴본 변수를 선언하는 방법과 마찬가지로 val, var을 사용한다. 

```kotlin
class Person(
	val name: String, //읽기 전용 프로퍼티. 비공개 필드와 단순한 공개 게터를 만든다.
	var isMarried: Boolean //쓸 수 있는 프로퍼티. 비공개 필드, 공개 게터, 공개 세터를 만든다.
)
```

기본적으로 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다. 
(읽기 전용 프로퍼티의 경우 게터만 선언하며, 변경할 수 있는 프로퍼티의 경우 게터와 세터를 모두 선언한다.)

코틀린은 값을 저장하기 위한 비공개 필드와 그 필드에 값을 저장하기 위한 세터, 필드의 값을 읽기 위한 게터로 이뤄진 간단한 디폴트 접근자 구현을 제공한다.

다음은 Person을 자바 코드에서 사용하는 방법을 보여준다.

```java
Person person = new Person("Bob", true);
System.out.println(person.getName());
-> Bob
System.out.println(person.isMarried());
-> true
```

게터와 세터의 이름을 정하는 규칙에는 예외가 있다. 이름이 is로 시작하는 프로퍼티의 게터에는 get이 붙지 않고 원래 이름 그대로 사용하며, 세터에는 is를 set으로 바꾼 이름을 사용한다. 

위 코드를 자바-코틀린 변환기로 변환한 결과는 다음과 같다.

```kotlin
val person = Person("Bob", true) //new 키워드를 사용하지 않음
println(person.name)
-> Bob
println(person.isMarried)
-> true
//프로퍼티 이름을 직접 사용해도 자동으로 게터를 호출해줌
```

게터를 호출하는 대신 프로퍼티를 직접 사용했음에 유의하라. 로직은 동일하지만 코드는 더 간결해졌다. 

(🌱자바에서 선언한 클래스에 대해 코틀린 문법을 사용해도 된다. 코틀린에서는 자바 클래스의 게터를 val 프로퍼티처럼 사용할 수 있고, 게터/세터 쌍이 있는 경우에는 var 프로퍼티처럼 사용할 수 있다.)

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있다. 이를 프로퍼티를 뒷받침하는 필드(backing field)라고 부른다. 하지만 원한다면 그때그때 계산할 수도 있다. 커스텀 게터를 작성하면 그런 프로퍼티를 만들 수 있다.

<br/>

### 2.2.2 커스텀 접근자
이번 절에서는 프로퍼티의 접근자를 직접 작성하는 방법을 보여준다. 직사각형 클래스인 Rectangle을 정의하면서 자신이 정사각형인지 알려주는 기능을 만들어보자. 직사각형이 정사각형인지를 별도의 필드에 저장할 필요가 없다. 사각형의 너비와 높이가 같은지 검사하면 정사각형 여부를 알 수 있다.

```kotlin
class Rectangle(val height: Int, val width: Int) {
	val isSquare: Boolean
		get() {
			return height == width
		}
}
```

isSquare 프로퍼티에는 자체 값을 저장하는 필드가 필요 없다. 이 프로퍼티에는 자체 구현을 제공하는 게터만 존재한다. 

블록을 본문으로 하는 구문을 꼭 사용하지 않아도 된다. 이런 경우 `get() = height == width`라고 할 수 있다. 

파라미터가 없는 함수를 정의하는 방식과 커스텀 게터를 정의하는 방식 중 어느 쪽이 더 나은지 궁금할 수 있다. 두 방식 모두 비슷하며, 구현이나 성능상의 차이는 없다. 차이가 나는 부분은 가독성뿐이다. 일반적으로 클래스의 특성을 정의하고 싶다면 프로퍼티로 그 특성(프로퍼티에는 특성이라는 뜻이 있다)을 정의해야 한다.

<br/>

### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지
모든 코틀린 파일의 맨 앞에 package 문을 넣을 수 있다. 그러면 그 파일 안에 있는 모든 선언(클래스, 함수, 프로퍼티 등)이 해당 패키지에 들어간다. 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있는 반면 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다. 자바와 마찬가지로 임포트문은 맨 앞에 와야 하며 import 키워드를 사용한다. 

```kotlin
package geometry.shapes
import java.util.Random

class Rectangle(val height: Int, val width: Int) {
		val isSquare: Boolean
			get() = height == width
}

fun createRandomRectangle(): Rectangle {
	val random = Random()
	return Rectangle(random.nextInt(), random.nextInt())
}
```

코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다. 

```kotlin
package geometry.example
import geometry.shapes.createRandomRectangle 

fun main(args: Array<Strgin>) {
	println(createRandomRectangle().isSquare)
}
```

패키지 이름 뒤에 `*`를 추가하면 패키지 안의 모든 선언을 임포트할 수 있다. 이런 스타 임포트(star import)를 사용하면 패키지 안에 있는 모든 클래스뿐 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러온다는 점에 유의해야 한다.

코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다. 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다. 따라서 원하는 대로 소스코드를 구성할 수 있다.

하지만 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다. 특히 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는게 중요하다. 자바 클래스를 코틀린 클래스로 마이그레이션할 때 문제가 생길 수도 있다. 하지만 여러 클래스를 한 파일에 넣는 것을 주저해서는 안 된다. 특히 각 클래스를 정의하는 소스코드 크기가 아주 작은 경우 더욱 그렇다.

<br/>

## 2.3 선택 표현과 처리: enum과 when
when은 자바의 switch를 대치하되 훨씬 더 강력하며, 앞으로 더 자주 사용할 프로그래밍 요소이다. when에 대해 설명하는 과정에서 코틀린에서 enum을 선언하는 방법과 스마트 캐스트에 대해서도 살펴본다.
<br/>
### 2.3.1 enum 클래스 정의
색을 표현하는 enum을 하나 정의한다. 

```kotlin
enum class Color {
	RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```

코틀린에서 enum은 소프트 키워드(soft keyword)라 부르는 존재다. enum은 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다. 반면 class는 키워드이다. 따라서 class라는 이름을 사용할 수 없으므로 클래스를 표현하는 변수 등을 정의할 때는 claaz나 aClass와 같은 이름을 사용해야 한다.

자바와 마찬가지로 enum은 단순히 값만 열거하는 존재가 아니다. enum 클래스 안에도 프로퍼티나 메소드를 정의할 수 있다. 다음은 프로퍼티와 메소드를 enum 안에 선언하는 방법을 보여준다.

```kotlin
enum class Color (
	val r: Int, val g: Int, val b: Int //상수의 프로퍼티 정의
) {
	//각 상수를 생성할 때 그에 대한 프로퍼티 값을 지정
	RED(255, 0, 0), ORANGE(255, 165, 0),
	YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
	INDIGO(75, 0, 130), VIOLET(238, 130, 238); //세미콜론 반드시 사용

	fun rgb() = (r * 256 + g) * 256 + b //enum 클래스 안에서 메소드를 정의
}

println(Color.BLUE.rgb())
-> 255
```

enum에서도 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다. 각 enum 상수를 정의할 때는 그 상수에 해당하는 프로퍼티 값을 지정해야만 한다. 이 예제에서는 코틀린에서 유일하게 세미콜론이 필수인 부분을 볼 수 있다. enum 클래스 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다.

<br/>

### 2.3.2 when으로 enum 클래스 다루기
무지개의 각 색에 대해 그와 상응하는 연상 단어를 짝지어주는 함수가 필요하다고 생각해보자. 그리고 그 연상 단어 정보를 enum안에 저장하지는 않는다고 하자. 자바라면 switch문으로 그런 함수를 작성할 수 있다. switch에 해당하는 코틀린 구성 요소는 `when`이다.

if와 마찬가지로 when도 값을 만들어내는 식이기에, 식이 본문인 함수에 when을 바로 사용할 수 있다. 

```kotlin
enum class Color (
    val r: Int, val g: Int, val b: Int //상수의 프로퍼티 정의
) {
    //각 상수를 생성할 때 그에 대한 프로퍼티 값을 지정
    RED(255, 0, 0), ORANGE(255, 165, 0),
    YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
    INDIGO(75, 0, 130), VIOLET(238, 130, 238); //세미콜론 반드시 사용

    fun rgb() = (r * 256 + g) * 256 + b //enum 클래스 안에서 메소드를 정의

    fun getMnemonic(color: Color) {
        when (color) {
            Color.RED -> "Richard"
            Color.ORANGE -> "Of"
            Color.YELLOW -> "York"
            Color.GREEN -> "Gave"
            Color.BLUE -> "Battle"
            Color.INDIGO -> "In"
            Color.VIOLET -> "Vain"
        }
    }
}
```

위 코드는 color로 전달된 값과 같은 분기를 찾는다. 자바와 달리 각 분기의 끝에 break를 넣지 않아도 된다. 성공적으로 매치되는 분기를 찾으면 switch는 그 분기를 실행한다. 한 분기 안에서 여러 값을 매치 패턴으로 사용할 수도 있는데, 이런 경우 값 사이를 콤마로 분리한다.

```kotlin
fun getWarmth(color: Color) = when (color) {
        Color.RED, Color.ORANGE, Color.YELLOW -> "warm"
        Color.GREEN -> "neutral"
        Color.BLUE, Color.INDIGO, Color.VIOLET -> "cold"
    }
println(getWarmth(Color.ORANGE))
```

<br/>

### 2.3.3 when과 임의의 객체를 함께 사용
코틀린에서 when은 자바의 switch보다 훨씬 더 강력하다. 분기 조건에 상수(enum 상수나 숫자 리터럴)만을 사용할 수 있는 자바 switch와 달리 코틀린 when의 분기 조건은 임의의 객체를 허용한다. 두 색을 혼합했을 때 미리 정해진 팔레트에 들어있는 색이 될 수 있는지 알려주는 함수를 작성한다. 

```kotlin
fun mix(c1: Color, c2: Color) =
        when (setOf(c1, c2)) {
            setOf(RED, YELLOW) -> ORANGE
            setOf(YELLOW, BLUE) -> GREEN
            setOf(BLUE, VIOLET) -> INDIGO
            else -> throw Exception("Dirty color") 
        }
```

c1과 c2가 RED와 YELLOW라면 혹은 그 반대라면 그 둘을 혼합한 결과는 ORANGE이다. 코틀린 표준 라이브러리에는 인자로 전달받은 여러 객체를 그 객체들을 포함하는 집한인 Set 객체로 만드는 setOf라는 함수가있다. 집합(set)은 원소가 모여 있는 컬렉션으로, 각 원소의 순서는 중요하지 않다. 

when 식은 인자 값과 매치하는 조건 값을 찾을 때까지 각 분기를 검사한다. 여기서는 setOf(c1, c2)와 분기 조건에 있는 객체 사이를 매치할 때 동등성(equality)을 사용한다. 그러므로 앞의 코드는 처음에는 setOf(c1, c2)와 setOf(RED,  YELLOW)를 비교하고, 그 둘이 같지 않으면 계속 다음 분기의 조건 객체와 setOf(c1, c2)를 차례로 비교하는 식으로 작동한다. 모든 분기 식에서 만족하는 조건을 찾을 수 없다면 else 분기의 문장을 계산한다.

다음 예제에서는 임의의 Boolean 식을 조건으로 사용하는 모습을 살펴본다.
<br/>

### 2.3.4 인자 없는 when 사용
전 함수는 호출될 때마다 함수 인자로 주어진 두 색이 when의 분기 조건에 있는 다른 두 색과 같은지 비교하기 위해 여러 Set 인스턴스를 생성한다. 보통은 이런 비효율성이 크게 문제가 되지 않는다. 하지만 이 함수가 아주 자주 호출된다면 불필요한 가비지 객체가 늘어나는 것을 방지하기 위해 함수를 고쳐쓰는 편이 낫다. 인자가 없는 when 식을 사용하면 불필요한 객체 생성을 막을 수 있다. 코드는 읽기 약간 어려워지지만 성능을 더 향상시키기 위해 그 정도 비용을 감수해야 하는 경우도 있다.

```kotlin
fun mixOptimized(c1: Color, c2: Color) =
        when {
            (c1 == RED && c2 == YELLOW) || 
						(c1 == YELLOW && c2 == RED) -> ORANGE
            (c1 == YELLOW && c2 == BLUE) || 
						(c1 == BLUE && c2 == YELLOW) -> GREEN
            (c1 == BLUE && c2 == VIOLET) || 
						(c1 == VIOLET && c2 == BLUE) -> INDIGO
            else -> throw Exception("Dirty color")
        }
```

when에 아무 인자도 없으려면 각 분기의 조건이 불리언 결과를 계산하는 식이어야 한다. mixOptimized 함수는 앞에서 살펴본 mix 함수와 같은 동작을 한다. mixOptimized는 추가 객체를 만들지 않는다는 장점이 있지만 가독성은 더 떨어진다.

<br/>

### 2.3.5 스마트 캐스트: 타입 검사와 타입 캐스트를 조합
  이번 절에서 사용할 예제로 (1 + 2) + 4와 같은 간단한 산술식을 계산하는 함수를 만들어보자. 함수가 받을 산술식에서는 오직 두 수를 더하는 연산만 가능하다. 

우선 식을 인코딩하는 방법을 생각해야 한다. 식을 트리 구조로 저장하자. 노드는 합계(sum)나 수(num) 중 하나다. Num은 항상 말단노드이지만, Sum은 자식이 둘 있는 중간노드로, 두 자식 노드는 덧셈의 두 인자이다. 

다음 코드는 식을 표현하는 간단한 클래스를 보여준다. 식을 위한 Expr 인터페이스가 있고, Sum과 Num 클래스는 그 Expr 인터페이스를 구현한다. Expr은 아무 메소드도 선언하지 않으며, 단지 여러 타입의 식 객체를 아우르는 공통 타입 역할만 수행한다. 

```kotlin
interface Expr
class Num(val value: Int): Expr
class Sum(val left: Expr, val right: Expr): Expr
```

Sum은 Expr의 왼쪽과 오른쪽 인자에 대한 참조를 left와 right 프로퍼티로 저장한다. 이 예제에서 left와 right는 각각 Num이나 Sum일 수 있다. 
(1 + 2) + 4라는 식을 저장하면 
Sum( Sum( Num(1), Num(2) ), Num(4) ) 라는 구조의 객체가 생긴다. 다음 그림은 이런 트리 표현을 보여준다.
<img width="367" alt="스크린샷 2021-09-12 23 33 56" src="https://user-images.githubusercontent.com/52916061/132991762-8528e34a-6144-43cd-afe2-9c02cb850646.png">
Expr 인터페이스에는 두 가지 구현 클래스가 존재한다. 따라서 식을 평가하려면 두 가지 경우를 고려해야 한다.

- 어떤 식이 수라면 그 값을 반환한다.
- 어떤 식이 합계라면 좌항과 우항의 값을 계산한 다음에 그 두 값을 합한 값을 반환한다.

코틀린에서 if를 사용해서 자바 스타일로 함수를 작성해보자.

```kotlin
fun eval(e: Expr): Int {
    if (e is Num) {
        val n = e as Num
        return n.value
    }
    if (e is Sum) {
        return eval(e.right) + eval(e.left)
    }
    throw IllegalArgumentException("Unknown expression")
}
```

코틀린에서는 is를 사용해 변수 타입을 검사한다. is 검사는 자바의 instanceOf와 비슷하다. 하지만 자바에서 어떤 변수의 타입을 instanceOf로 확인한 다음에 그 타입에 속한 멤버에 접근하기 위해서는 명시적으로 변수 타입을 캐스팅해야 한다. 이런 멤버 접근을 여러 번 수행해야 한다면 변수에 따로 캐스팅한 결과를 저장한 후 사용해야 한다. 코틀린에서는 프로그래머 대신 **컴파일러가 캐스팅을 해준다**. 어떤 변수가 원하는 타입인지 일단 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다. 이를 **스마트 캐스트**(smart cast)라고 부른다.

eval 함수에서 e의 타입이 Num인지 검사한 다음 부분에서 컴파일러는 e의 타입을 Num으로 해석한다. 그렇기 때문에 Num의 프로퍼티인 value를 명시적 캐스팅 없이 e.value로 사용할 수 있다. Sum의 프로퍼티인 right와 left도 마찬가지다. IDE를 사용하면 스마트 캐스트 부분의 배경색을 달리 표시해주므로 이런 변환이 자동으로 이뤄졌음을 쉽게 알 수 있다.

스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다. 예를 들어 앞에서 본 예제처럼 클래스의 프로퍼티에 대해 스마트 캐스트를 사용한다면 그 프로퍼티는 반드시 val이어야 하며 커스텀 접근자를 사용한 것이어도 안된다. val이 아니거나 val이지만 커스텀 접근자를 사용하는 경우에는 해당 프로퍼티에 대한 접근이 항상 같은 값을 내놓는다고 확신할 수 없기 때문이다. 

원하는 타입으로 명시적으로 타입 캐스팅하려면 위 코드처럼 `as` 키워드를 사용한다.

<br/>

### 2.3.6 리팩토링: if를 when으로 변경
```kotlin
    fun eval(e: Expr): Int =
        when (e) {
            is Num ->
                e.value
            is Sum ->
                eval(e.right) + eval(e.left)
            else ->
                throw IllegalArgumentException("Unknown Exception")
        }
```

이 예제는 받은 값의 타입을 검사하는 when 분기를 보여준다. 앞의 if 예제와 마찬가지로 타입을 검사하고 나면 스마트 캐스트가 이루어진다. 

when과 if 식을 사용한 함수를 서로 비교해보고, when으로 if를 대신할 수 있는 경우가 언제인지 생각해보자. if나 when의 각 분기에서 수행해야 하는 로직이 복잡해지면 분기 본문에 블록을 사용할 수 있다.

<br/>

### 2.3.7 if와 when의 분기에서 블록 사용
if나 when 모두 분기에 블록을 사용할 수 있다. 그런 경우 블록의 마지막 문장이 블록 전체의 결과가 된다. 예제로 봤던 함수에 로그를 추가하고 싶다면 각 분기를 블록으로 만들고 블록의 맨 마지막에 그 분기의 결과 값을 위치시키면 된다.

```kotlin
    fun evalWithLogging(e: Expr): Int =
        when (e) {
            is Num -> {
                println("num: ${e.value}")
                e.value  //e의 타입이 Num이면 e.value 반환
            }
            is Sum -> {
                val left = evalWithLogging(e.left)
                val right = evalWithLogging(e.right)
                println("sum: $left + $right")
                left + right //e의 타입이 Sum이면 left+right 반환
            }
            else -> throw   IllegalArgumentException("Unknown expression")
        }
```

블록의 마지막 식이 블록의 결과 라는 규칙은 블록이 값을 만들어내야 하는 경우 항상 성립한다. 앞에서 설명한 대로 이 규칙은 함수에 대해서는 성립하지 않는다. 식이 본문인 함수는 블록을 본문으로 가질 수 없고 블록이 본문인 함수는 내부에 return문이 반드시 있어야 한다.

<br/>

## 2.4 대상을 이터레이션: while과 for 루프

while은 자바와 동일하므로 간략하게 다루고 넘어가며, for는 자바의 for-each 루프에 해당하는 형태만 존재한다.

<br/>

### 2.4.1 while 루프
코틀린에는 while과 do-while 루프가 있다. 

```kotlin
    while(조건) {
    	//조건이 참인 동안 본문을 반복 실행
    } 

    do {
    	//맨 처음에 무조건 본문을 한 번 실행한 다음,
    	// 조건이 참인 동안 본문을 반복 실행
    } while(조건)
```
<br/>

### 2.4.2 수에 대한 이터레이션: 범위와 수열

앞에서 설명했지만 코틀린에는 자바의 for 루프에 해당하는 요소가 없다. 이런 루프의 가장 흔한 용례인 초깃값, 증가 값, 최종 값을 사용한 루프를 대신하기 위해 코틀린에서는 `범위(range)`를 사용한다.
범위는 기본적으로 두 값으로 이뤄진 구간이다. 보통 그 두 값은 정수 등의 숫자 타입의 값이며, `..` 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다.
코틀린의 범위는 폐구간(닫힌 구간) 또는 양끝을 포함하는 구간이다. 이는 1..10 이면 10을 포함하는 뜻이다.
정수 범위로 수행할 수 있는 가장 단순한 작업은 범위에 속한 모든 값에 대한 이터레이션이다. 이런 식으로 어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우를 `수열(progression)`이라고 부른다.
피즈버즈게임을 위해 정수 범위를 사용해보자. 참가자는 순차적으로 수를 세면서 3으로 나눠떨어지는 수에 대해서는 피즈, 5로 나눠떨어지면 버즈라고 말한다. 3과5로 모두 나눠떨어지면 피즈버즈라고 말해야 한다.

```kotlin
    fun fizzBuzz(i: Int) = when {
        i % 15 == 0 -> "FizzBuzz"
        i % 3 == 0 -> "Fizz"
        i % 5 == 0 -> "Buzz"
        else -> "$i"
    }
    >>> for (i in 1..100) {
    		...print(fizzBuzz(i))
    		...}
    }
```

이제는 100부터 거꾸로 세되 짝수만으로 게임을 진행해보자.

```kotlin
    >>> for (i in 100 downTo 1 step 2) {
    		...print(fizzBuzz(i))
    		...}
    }
```

여기서는 증가 값 step을 갖는 수열에 대해 이터레이션한다. 증가 값을 사용하면 수를 건너 뛸 수 있다. 증가 값을 음수로 만들면 정방향 수열이 아닌 역방향 수열을 만들 수 있다. 
앞에서 언급한 대로 `..`는 항상 범위의 끝 값을 포함한다. 하지만 끝 값을 포함하지 않는 반만 닫힌 범위에 대해 이터레이션하면 편할때가 자주 있다. 그런 범위를 만들고 싶다면 until 함수를 사용한다.

<br/>

### 2.4.3 맵에 대한 이터레이션
이런 for 루프는 자바와 마찬가지로 작동하기 때문에 설명할 내용이 많지 않다. 대신 맵에 대한 이터레이션을 살펴보자.
문자에 대한 2진 표현을 출력하는 프로그램을 살펴보자. 이대 2진 표현을 맵에 저장하자. 다음 코드는 맵을 만들고, 몇 글자에 대한 2진 표현으로 맵을 채운 다음, 그 맵의 내용을 출력한다.

```kotlin
    val binaryReps = TreeMap<Char, String>()

    fun binaryFunc() {
        for (c in 'A'..'F') {
            val binary = Integer.toBinaryString(c.toInt())
            binaryReps[c] = binary
        }

        for ((letter, binary) in binaryReps) {
            println("$letter = $binary")
        }
    }
```

`..` 연산자를 숫자 타입의 값뿐 아니라 문자 타입의 값에도 적용할 수 있다. 위 코드는 for 루프를 사용해 이터레이션하려난 컬렉션의 원소를 푸는 방법을 보여준다. 원소를 풀어서 letter와 binary라는 두 변수에 저장하며, letter에는 키가 들어가고, binary에는 2진 표현이 들어간다.

맵에 사용했던 구조 분해 구문을 맵이 아닌 컬렉션에도 활용할 수 있다. 그런 구조 분해 구문을 사용하면 원소의 현재 인덱스를 유지하면서 컬렉션을 이터레이션할 수 있다. 

<br/>

### 2.4.4 in으로 컬렉션이나 범위의 원소 검사
`in` 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있다. 반대로 `!in`을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다. 다음은 어떤 문자가 정해진 문자의 범위에 속하는지를 검사하는 방법을 보여준다.

```kotlin
    fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
    fun isNotDigit(c: Char) = c !in '0'..'9'

    println(isLetter('q')) -> true
    println(isNotDigit('x')) -> true
```

이렇게 어떤 문자가 글자인지 검사하는 방법은 간단해 보인다. 내부적으로도 교묘한 부분은 전혀 없다. 이렇게 코드를 작성해도 여전히 문자의 코드가 범위의 첫 번째 글자의 코드와 마지막 굴자의 코드 사이에 있는지를 비교한다. 하지만 그런 비교 로직은 표준 라이브러리의 범위 클래스 구현 안에 깔끔하게 감춰져 있다.

```kotlin
    c in 'a'..'z' // 다음처럼 변환된다.
    'a' <= c && c <= 'z'
```

범위는 문자에만 국한되지 않고, 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다. Comparable을 사용하는 범위의 경우 그 범위 내의 모든 객체를 항상 이터레이션하지는 못한다. 예를 들어 'Java'와 'Kotlin' 사이의 모든 문자열을 이터레이션할 수 있을까? 그럴 수 없다. 하지만 in 연산자를 사용하면 값이 범위 안에 속하는지 결정할 수 있다.

<br/>

## 2.5 코틀린의 예외 처리

코틀린의 예외처리는 자바나 다른 언어와 비슷하다. 함수는 정상적으로 종료할 수 있지만 오류가 발생하면 예외를 던질 수 있다. 함수를 호출하는 쪽에서는 그 예외를 잡아 처리할 수 있다. 

### 2.5.1 try, catch, finally
자바와 마찬가지로 예외를 처리하려면 try와 catch, finally 절을 함께 사용한다. 파일에서 각 줄을 읽어 수로 변환하되 그 줄이 올바른 수 형태가 아니면 null을 반환하는 다음 예제에서 그 세 가지 요소를 볼 수 있다.

```kotlin
    fun readNumber(reader: BufferedReader): Int? {
        try {
            val line = reader.readLine()
            return Integer.parseInt(line)
        }
        catch(e: NumberFormatException) {
            return null
        }
        finally {
            reader.close()
        }
    }
```

자바 코드와 가장 큰 차이는 throws 절이 코드에 없다는 점이다. 자바에서는 함수를 작성할 때 함수 선언 뒤에 throws IOException을 붙여야 한다. 이유는 IOException이 체크 예외이기 때문이다. 자바에서는 체크 예외를 명시적으로 처리해야 한다. 어떤 함수가 던질 가능성이 있는 예외나 그 함수가 호출한 다른 함수에서 발생할 수 있는 예외를 모두 catch로 처리해야 하며, 처리하지 않은 예외는 throws 절에 명시해야 한다.
다른 최신 JVM 언어와 마찬가지로 코틀린도 체크 예외와 언체크 예외를 구별하지 않는다. 코틀린에서는 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다. 
자바는 체크 예외 처리를 강제하지만 프로그래머들이 의미 없이 예외를 다시 던지거나, 예외를 잡되 처리하지는 않고 그냥 무시하는 코드를 작성하는 경우가 흔하다. 그로 인해 예외 처리 규칙이 실제로는 오류 발생을 방지하지 못하는 경우가 자주 있다. 
자바 7 의 자원을 사용하는 try-with-resource는 어떨까? 코틀린은 그런 경우를 위한 특별한 문법을 제공하지 않는다. 하지만 라이브러리 함수로 같은 기능을 구현하다. 

### 2.5.2 try를 식으로 사용

자바와 코틀린의 중요한 차이를 살펴보기 위해 방금 살펴본 예제를 고쳐보자. finally 절을없애고 파일에서 읽은 수를 출력하는 코드를 추가하자.

```kotlin
    fun readNumber(reader: BufferedReader) {
        val number = try {
            Integer.parseInt(reader.readLine())
        } catch(e: NumberFormatException) {
            return
        }
        println(number)
    }
```
코틀린의 try 키워드는 if나 when과 마찬가지로 식이다. 따라서 try의 값을 변수에 대입할 수 있다. if와 달리 try의 본문을 반드시 중괄호로 둘러싸야 한다. 다른 문장과 마찬가지로 try의 본문도 내부에 여러 문장이 있으면 마지막 식의 값이 전체 결과 값이다.
이 예제는 catch 블록 안에서 return 문을 사용한다. 따라서 예외가 발생할 경우 catch 블록 다음의 코드는 실행되지 않는다. 하지만 계속 진행하고 싶다면 catch 블록도 값을 만들어야 한다. 역시 catch 블록도 그 안의 마지막 식이 블록 전체의 값이 된다. 다음은 그런 동작을 보여준다.

```kotlin
    fun readNumber(reader: BufferedReader) {
        val number = try {
            Integer.parseInt(reader.readLine())
        } catch(e: NumberFormatException) {
            null
        }
        println(number)
    }
```
try 코드 블록의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과다. 예외가 발생하고 잡히면 그 예외에 해당하는 catch 블록의 값이 결과다. 위 코드에서 예외가 발생하면 함수의 결과값이 null이 된다.



### 2.6 요약

- 함수를 정의할 때 fun 키워드를 사용한다. val과 var는 각각 읽기 전용 변수와 변경 가능한 변수를 선언할 때 쓰인다.
- 문자열 템플릿을 사용하면 문자열을 연결하지 않아도 되므로 코드가 간결해진다. 변수 이름 앞에 **`$`**를 붙이거나, 식을 **`${식}`**처럼 둘러싸면 변수나 식의 값을 문자열 안에 넣을 수 있다.
- 코틀린에서는 값 객체 클래스를 아주 간결하게 표현할 수 있다.
- 다른 언어에도 있는 if는 코틀린에서 식이며, 값을 만들어낸다.
- 코틀린 when은 자바의 switch와 비슷하지만 더 강력하다.
- 어떤 변수의 타입을 검사하고 나면 굳이 그 변수를 캐스팅하지 않아도 검사한 타입의 변수처럼 사용할 수 있다. 그런 경우 컴파일러가 스마트 캐스트를 활용해 자동으로 타입을 바꿔준다.
- for, while, do-while 루프는 자바가 제공하는 같은 키워드의 기능과 비슷하다. 하지만 코틀린의 for는 자바의 for보다 더 편리하다. 특히 맵을 이터레이션하거나 이터레이션하면서 컬렉션의 원소와 인덱스를 함께 사용해야 하는 경우 코틀린의 for가 더 편리하다.
- 1..5와 같은 식은 범위를 만든다. 범위와 수열은 코틀린에서 같은 문법을 사용하며, for 루프에 대해 같은 추상화를 제공한다. 어떤 값이 범위 안에 들어있거나 들어있지 않은지 검사하기 위해서 `in`이나 `!in`을 사용한다.
- 코틀린 예외 처리는 자바와 비슷하지만 코틀린에서는 함수가 던질 수 있는 예외를 선언하지 않아도 된다.

